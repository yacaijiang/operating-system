物理和虚拟寻址
主存被组织成一个由M个连续的字节大小单元组成的数组。每字节都有一个唯一的物理地址。

CPU访问内存的最自然的方式就是使用物理地址，这种方式称为物理寻址。

现代处理器使用一种虚拟寻址的寻址形式。

使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存。

地址翻译：虚拟地址转换为物理地址。
地址空间是一个非负整数地址的有序集合
线性地址空间： 地址空间的整数是连续的

虚拟内存：被组织为一个由存放在磁盘上的N个连续字节大小的单元组成的数组，每字节都有一个唯一的虚拟地址，作为到数组的索引。
磁盘上数组的内容被缓存在主存中。

虚拟页面的集合：
未分配的：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
缓存的：当前已缓存在物理内存中的已分配页。
未缓存的：未缓存在物理内存中的已分配页

SRAM缓存：表示位于CPU和主存之间的L1,L2,和L3高速缓存
DRAM缓存：表示虚拟内存系统的缓存，在主存中缓存虚拟页

页表：虚拟页映射到物理页
每次地址翻译硬件将一个虚拟地址转换为物理地址，都会读取页表

页表就是一个页表条目PTE的数组。
假设每个PTE由一个有效位和一个n位地址字段组成。
有效位表示该虚拟页当前是否缓存在DRAM中。
如果设置了有效位，地址字段表示DRAM中物理页的起始位置。
若没有设置有效位，地址字段表示虚拟页在磁盘上的起始位置。

页命中：虚拟页在DRAM中
缺页：DRAM缓存不命中称为缺页。

VPO:虚拟页面偏移量
VPN：虚拟页号
PPO：物理页面偏移量
PPN：物理页号

TLB：翻译后备缓冲器

内存映射：Linux通过将一个虚拟内存区域和一个磁盘上的对象关联起来，初始化这个虚拟内存区域的内容。

Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件
文件区被分成页大小的片，每一片包含一个虚拟页面的初始内容。
匿名文件：一个区域也可以映射到一个匿名文件。匿名文件由内核创建，包含的全是二进制零。

一个对象可以被映射到虚拟内存的一个区域，作为共享对象或者私有对象

写时复制：私有对象开始生命周期的方式基本与共享对象一样，对于每个映射私有对象的进程，相应私有区域的页表条目被标记为只读，并且区域结构被标记为私有的写时复制。
当一个进程试图写私有区域内的某个页面，该写操作就会触发一个保护故障。
当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的页面引起的，它就会在物理内存中创建这个页面的一个新的副本。
更新页表条目指向新副本，恢复这个页面的可写权限，之后故障处理程序返回时，CPU重新执行写操作，新创建的页面上这个写操作就可以正常执行了。


fork函数
被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。
为了给这个新的创建虚拟内存，创建当前进程的mm_struct、区域结构和页表的原样副本。
它将两个进程中的每个页面都标记为只读，并且将两个进程中的每个区域结构都标记为私有的写时复制。

execve函数
加载和执行程序
execve("a.out",NULL,NULL);
加载并运行a.out需要以下几步：
删除已存在的用户区域。
映射私有区域
映射共享区域
设置程序计数器


使用mmap函数的用户级内存映射：
Linux进程可以使用mmap函数创建新的虚拟内存区域，并将对象映射到该区域中。
mmap函数要求内核创建一个新的虚拟内存区域，并且将文件描述符fd指定的对象的一个连续的片映射到这个新的区域

动态内存分配：
可以使用低级的mmap和munmap创建和删除虚拟内存区域，但是动态内存分配器更方便，也有更好的可移植性。
动态内存分配器维护一个进程的虚拟内存区域，称为堆heap，
对于每个进程内核维护一个变量brk（读作break）指向堆得顶部。
分配器将堆视作一组不同大小的块block的集合来维护，每个块就是一个连续的虚拟内存片，已分配的或者空闲的
已分配的块显示地保留为供应用程序使用。空闲块可以用来分配。

显示分配器：要求应用显式地释放任何已分配的块。c通过调用malloc函数分配一个块，通过调用free函数来释放一个块。
c++中new和delete

隐式分配器：又称为垃圾收集器，自动释放未使用的已分配的块的过程叫做垃圾收集。

malloc和free
malloc函数返回一个指针，指向大小为至少size字节的内存块，这个块会为可能包含在块内的任何数据对象类型做对齐。
malloc不初始化它返回的内存，想要已初始化的动态内存的应用程序使用calloc，基于malloc的瘦包装函数，将分配的内存初始化为零，
想要改变一个以前已分配的块的大小，可以使用realloc函数

free函数释放已分配的堆块
ptr参数必须指向一个从malloc、calloc、realloc获得的已分配块的起始位置。

显式分配器必须在一些相当严格的约束条件下工作：
处理任意请求序列
立即响应请求
只使用堆
对齐块
不修改已分配的块

碎片：
内部碎片：在一个已分配块比有效载荷大时发生。为了满足对齐约束，分配器可能会增加块大小。
外部碎片：当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以处理请求时发生。

隐式空闲链表：

放置已分配的块：
首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块
下一次适配：从链表上一次查询结束的地方开始，选择第一个合适的空闲块。
最佳适配：检查每一个空闲块，找到最适合请求大小的最小空闲块

显式空闲链表：

分离的空闲链表：
使用单向空闲块链表的分配器需要与空闲块数量呈线性关系来分配块。
分离存储：维护多个空闲链表，其中每个链表中的块有大致相等的大小。
常用思路：将可能的块大小分成一些等价类，也叫做大小类。


简单分离存储：
每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。

分离适配：
分配器维护一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显示或者隐式链表。


垃圾收集器：动态内存分配器，自动释放程序不再需要的已分配块。

mark&sweep垃圾收集器： 
由标记mark阶段和清除sweep阶段组成。
标记阶段：标记出根节点的所有可达的和已分配的后继，
清除阶段：释放每一个未被标记的已分配块。

c程序中常见的与内存有关的错误
间接引用坏指针：
读 未初始化的内存：
允许栈缓冲区溢出：
假设指针和它们指向的对象是相同大小的：
造成错位错误：
引用指针，而不是它所指向的对象：
误解指针运算：
引用不存在的变量：
引用空闲堆块中的数据：
引起内存泄漏：

